---
layout: post
title:  "ES6 Status II"
date:   2018-04-02
categories: javascript
---

### destructuring objects

Can extract data from arrays, objects, maps and sets.

This I actually found pretty cool. There have been a few instances I have broken down things into multiple parts, writing extra... until...

```
let quote = item.saying;
let author = item.author;

```

vs.

```
let { saying:quote, author } = item;

```

How awesome is that?^ AND the `saying:quote` part is me storing `saying` into `quote` variable! Yes, I dig it and am stoked to use it.

Destructuring would also come in handy for deep nested data, like with an API. Thinking back, I'm pretty sure the Dark Sky API I used for my weather app had a few of those.

```
const you = {
	first: 'NAME HERE'
	links: {
		social: {
			twitter: 'https://twitter.com/USERNAME', 
			github: 'https://github.com/USERNAME'
		}
	}
}

const { twitter, github } = you.links.social;

```

SETTING DEFAULTS:

`const settings = { width: 500, color: 'black' }` 

`const { width=100 height=500, color='pink', fontSize=32 } = settings;`

2nd line above has defaults set, in other words as it deconstructs settings obj it checks if there's a match. If so, it moves on and if not, it takes the default.

BREAKDOWN: width is included in the 1st line (settings) so it stays at 500, height takes 500 which is set as default in 2nd line (destructuring line), there is color in settings so it stays black, but fontSize, like height is not so it takes default set, 32

### destructuring arrays

Just like objects, there's a way to simplify life with arrays. The difference, object destructuring uses curly braces, while arrays used square brackets.

```
const details = ['scrappy', '14', 'brindle'];

const name = details[0];
const age = details[1];
const age = details[2];


```

vs.

```
const details = ['scrappy', '14', 'brindle'];

const [name, age, color] = details;

console.log(name, age, color); // scrappy 14 brindle

```

Note: There will also be a difference when destructuring maps and sets, maps uses curly braces, while sets use square brackets.

Also helpful when dealing with a [comma] list/string:

```
const data = 'sport, basketball, shaq, 32, retired';

const[category, type, player, number, status] = data.split(',');

console.log(category, type, player, number, status);

```

^At first, I had used a `let` instead of `const` to split data and reassign variable, but turns out there is a simplier/ better way to do that and that's just add it to the destructure (w00t!)

```
const data = 'sport, basketball, shaq, 32, retired, yourFace';

const[category, type, player, number, status] = data.split(',');

console.log(category, type, player, number, status);

```
^What happens when you want to destructure something that doesnt match length of array? Nothing.
Output will actually remain the same since the last part of the string was not destructured.

But, how about those times you do want the rest?
```
const cockpit = ['Clarence', 'Roger', 'Striker', 'Doctor', 'Nun'];

const [pilot, co-pilot, ...passengers] = cockpit;

```
^ you'd destructure as usual, but use the *rest operator* to snag the *rest* :D

### swapping variables with destructuring

When you need to toggle between variables:
```
let onCourt = 'DWade';
let offCourt = 'UD';

console.log(onCourt, offCourt); // will show org

[onCourt, offCourt] = [offCourt, onCourt];

console.log(onCourt, offCourt); // will show swap

```
^ Will create an array and destructure into opp variables. Since updating variables -> using `let`

### destructuring functions - multi returns + named defaults

Multi- Returns:
```
function convertCurrency(amount) {
	const converted = {
		USD: amount * 0.76,
		MEX: amount * 13.30,
		GPB: amount * 0.53
	}
	return converted;
}

const hundo = convertCurrency(100);
console.log(hundo);

console.log(hundo.MEX); // to return specific value

```
Destructuring to return multi values from a function is a cheat since you can't *really*, but u *can* return an obj with a restructured answer.

```
function convertCurrency(amount) {
	const converted = {
		USD: amount * 0.76,
		MEX: amount * 13.30,
		GPB: amount * 0.53
	}
	return converted;
}

const {  MEX, USD, GPB } = convertCurrency(100);

console.log(USD, MEX, GPB);

```
^Desctructuring in this manner, able to snag specific value. The order that is is destructured doesn't affect value return since it is an object.

Note: It isnt necessary to destructure all if, let's say, only USD and GPB is needed.

Named Defaults:
```
function tipCalc({total, tip=0.15, tax=0.13}) {
	return total + (tip * total) + (tax * total);
}

const bill = tipCalc({ total: 200, tax: 0.09 });
console.log(bill);

```
Making order of values independent, you wrap params in curly braces. Pass obj will destructure into 3 variables (total, tip, tax)/make available inside function. When called, you pass obj with values, they do not have to be in exact order and it is possible to leave unneeded values out.

If NO arguments are passed:
```
function tipCalc({total=200, tip=0.25, tax=0.09} = {}) {
	return total + (tip * total) + (tax * total);
}

const bill = tipCalc();
console.log(bill);

```

For cases where no obj are passed to destructure against, calling function, you have to give itself a default argument. If no object is passed it will default to blank obj and all defaults will be in there.

### iterables & looping

`const dogs = ['beagle', 'dalmation', 'golden retriever', 'pug', 'labrador'];`


The classic `for loop`
The following type of for loop became the main one used, but only after getting some used to. Although, it does do what it's meant to do, syntax may not be as readable as it could be.
```
for(let i = 0; i < dogs.length; i++) {
  console.log(dogs[i]);
}

```


Then, there's the `forEach`
This one actually made the most sense to me when I first started trying to wrap my head around JavaScript. The reason, I got my basic grasp of web dev workings messing with Ruby which had something similar.
```
dogs.forEach((dog) => {
	console.log(dog);
})

```
Cannot pause loop, cannot skip items
Cannot use `break` or `continue` inside a `forEach` loop


The `for in` loop:
```
for(const index in dogs) {
	console.log(dogs[index]);
}

``` 
This gives index, snag values as follows, but...

there are many methods on a prototype, if you were to add one and then reiterate it will reiterate all things in array including anything added. [example] custom prototype method or property added to array.


The `for of` loop:
```
for(const dog of dogs) {
	console.log(dog)
}

```
This is like the one that brings all the good stuff from those above into one, sorta. It will return what is in the array w/o anything extra like if prototype was modified and able to use `break` and `continue`. NOTE: `for of` loops can be used on anything except objects.

### for of loop on the field

```
for(const dog of dogs) {
	console.log(dog)
}

// will output:
beagle
dalmation
golden retriever
pug
labrador

```

^Seems there really isnt a good way to snag index.

In comes `dogs.entries()` which `console.log`s an Array Iterator with a `next()` method
```
dogs.entries()
	Array Iterator
	​
		__proto__: Array Iterator
		​​
		next: next()
		​​​
		length: 0
		​​​
		name: "next"
		​​​
		__proto__: ()
		​​​​
		apply: function apply()
		​​​​
		arguments: null
		​​​​
		bind: function bind()
		​​​​
		call: function call()
		​​​​
		caller: null
		​​​​
		constructor: function Function()
		​​​​
		length: 0
		​​​​
		name: ""
		​​​​
		toSource: function toSource()
		​​​​
		toString: function toString()
		​​​​
		Symbol(Symbol.hasInstance): undefined
		​​​​
		__proto__: Object { … }
		​​
		Symbol(Symbol.toStringTag): undefined
		​​
		__proto__: {…}
		​​​
		Symbol(Symbol.iterator): undefined
		​​​
		__proto__: Object { … }

```
When stored in a variable `const pups = dogs.entries();` you are able to iterate manually `pups.next();`, but placing it within `for of` loop `console.log`s

```
for(const dog of dogs.entries()) {
	console.log(dog)
}

// will output:
Array [ 0, "beagle" ]
Array [ 1, "dalmation" ]
Array [ 2, "golden retriever" ]
Array [ 3, "pug" ]
Array [ 4, "labrador" ]

```

However, present setup requires `console.log(dog[0], dog[1]);` to get index with dog
```
// console.log output:
0 beagle
1 dalmation
2 golden retriever
3 pug
4 labrador

```

A better approach, destructuring with optional use of template strings
```
for(const [i, dog] of dogs.entries()) {
	console.log(`${i}: ${dog}`);
}

// will output:
0: beagle
1: dalmation
2: golden retrieve
3: pug
4: labrador

```

Iterating using `arguments`:
```
function addUpNum() {
	let total = 0;
	for (const num of arguments) {
		total += num;
	}
	console.log(total);
	return total;
}

addUpNum(10, 20, 32, 35, 15); // 112

```

Using arguments gives you something similar to an array, but it is NOT an array. 
```
function addUpNum() {
	console.log(arguments);	
}

addUpNum(10, 20, 32, 35, 15); // 112

// console.log returns:

Arguments
​
0: 10
​
1: 20
​
2: 32
​
3: 35
​
4: 15
​
callee: function addUpNum()
​
length: 5
​
Symbol(Symbol.iterator): undefined
​
__proto__: Object { … }

```

A true array will show prototype methods included with arrays, arguments will only provide length. However, arguments will provide iterator method.
```
// console.log([10, 20, 32, 35, 15]) returns

Array(5) […]
​
0: 10
​
1: 20
​
2: 32
​
3: 35
​
4: 15
​
length: 5
​
__proto__: []
​​
concat: function concat()
​​
constructor: function Array()
​​
copyWithin: function copyWithin()
​​
entries: function entries()
​​
every: function every()
​​
fill: function fill()
​​
filter: function filter()
​​
find: function find()
​​
findIndex: function findIndex()
​​
forEach: function forEach()
​​
includes: function includes()
​​
indexOf: function indexOf()
​​
join: function join()
​​
keys: function keys()
​​
lastIndexOf: function lastIndexOf()
​​
length: 0
​​
map: function map()
​​
pop: function pop()
​​
push: function push()
​​
reduce: function reduce()
​​
reduceRight: function reduceRight()
​​
reverse: function reverse()
​​
shift: function shift()
​​
slice: function slice()
​​
some: function some()
​​
sort: function sort()
​​
splice: function splice()
​​
toLocaleString: function toLocaleString()
​​
toSource: function toSource()
​​
toString: function toString()
​​
unshift: function unshift()
​​
values: function values()
​​
Symbol(Symbol.iterator): undefined
​​
Symbol(Symbol.unscopables): undefined
​​
__proto__: Object { … }

```

NOTE: It is possible and sometimes may be neccessary to convert `arguments` into an array, but if kept as is those would be differences to keep in mind.

Iterating strings:
```
const name = 'MysticalState'

for(const char of name) {
	console.log(char);
}

```
NOTE: remember to put in `const`, `let`, or even `var` in `for of` loop as usual or it will override the actual variable every single time instead of creating a scoped variable to that block.

Iterate over DOM collections without converting to array:
```
... html, body and all that jazz here

<p>P 01</p>
<p>P 02</p>
<p>P 03</p>
<p>P 04</p>
<p>P 05</p>


<script>
const ps = document.querySelectorAll('p');
console.log(ps);
</script>
</body>
</html>

```
^This `console.log`s NodeList which offers array methods on certain browsers, but not all. May have to convert to true array.

```
const ps = document.querySelectorAll('p');

for(const paragraph of ps) {
	// console.log(paragraph);
	
	paragraph.addEventListener('click', function() {
		console.log(this.textContent);
	})
}

```
Able to use `for of` on things even when they are not arrays as long as they are iterable.
*What are iterables?* DOM collections, strings, arguments, arrays, maps, sets

### no objects with for of loops, yea?

```
const watermelon = {
	size: 'large',
	weight: 100,
	type: 'fruit'
}

for(const prop of watermelon) {
	console.log(prop); // ERROR
}

```
^TypeError: watermelon is not iterable

So, what *CAN* we do?
`Object.values()` and `Object.entries()`

Presently, giving `TypeError: watermelon.entries is not a function` error *womp womp womp*, however according to [proposals](https://github.com/tc39/proposal-object-values-entries) they will be included in ES2017.

NOTE: [polyfill is available](https://github.com/es-shims/Object.entries)

*What is a polyfill?* adds unsupported features back in

If you can't use a polyfill?
```
const watermelon = {
	size: 'large',
	weight: 100,
	type: 'fruit'
}

for(const prop of Object.keys(watermelon)) {
	console.log(prop); // gives size, weight, type
}

```

```
const watermelon = {
	size: 'large',
	weight: 100,
	type: 'fruit'
}

for(const prop of Object.keys(watermelon)) {
	const values = watermelon[prop];
	
	console.log(prop, values); // outputs size, weight, type and large, 100, fruit
}

```

Not the cleanest solution since we're going outside to snag stuff, but it is possible to use. Of course, using `for of` loop isn't exactly necessary. There are other options like `for in` loop which will give same output without the use of `Object.keys()`

```
const watermelon = {
	size: 'large',
	weight: 100,
	type: 'fruit'
}

for(const prop in watermelon) {
	const values = watermelon[prop];
	// console.log(prop); // outputs size, weight, type
	console.log(prop, values); // outputs large, 100, fruit
}

```
^best option to use for objects until `Object.values()` and `Object.entries()` arrive

### array stufffffff

`.from()` & `.of()` are not part of the prototype. Creating an array `const ages = [13, 15, 21, 32, 35];` and `console.log`-ing `ages.from()` or `ages.of()` would result in a `TypeError: ages.from is not a function` error.

On Array itself however, `Array.from()` or `Array.of()` would be used to convert something that's Array-ish into a legit Array (liiiiiike NodeLists or arguments).

NodeList -> Array:
```
<div class="kids">
	<p>Scrappy</p>
	<p>Enigma</p>
	<p>Sammy</p>
</div>

<script>
const kids = Array.from(document.querySelectorAll('.kids p'));
console.log(kids);
const names = kids.map(kids => kids.textContent);
console.log(names); 

</script>
</body>
</html>
```

`Array.from()` can take a 2nd argument, a map function. Instead, of using `Array.from()` on the doc selector use `Array.from();` giving it 2 arguments, the first have the NodeList, the second a function to map over list

```
const kids = document.querySelectorAll('.kids p');

console.log(kids); // ^NodeList

const names = Array.from(kids, kid => {
	console.log(kid); // outputs actual DOM node
	return kid.textContent;
});

console.log(names); // array of names

```

Arguments -> Arrays:
```
function sumAll() {
	// console.log(arguments);
	const arr = Array.from(arguments);
	return arr.reduce((prev, next) => prev + next, 0);
}

sumAll(2, 4, 6, 8);

```

`Array.of()` is pretty straight forward
```
const ages = Array.of(12, 15, 4);
console.log(ages);

```
Looking through the proto dropdown you'll see all the usual Array type stuff like `.join()`, `.pop()`, `.push()`, etc.


- - -


`Array.find()` & `Array.findIndex()`

Common use case is when looking through data that has come from an API, example an array of object items.

`.find()` will return a true or false. Example: `const post = Posts.find(post => post.code === 'whatevercodehere');` will iterate through until it finds specific post, `console.log(post);` will output found obj containing what you had it look for (if it actually is there, of course).

If you were looking for multiple, `.filter()` would be output an array of objects, not just one like above.

`.findIndex()` is when you know what you want, but looking for where in the array it is, position/index-wise. Use case? Position in array to delete item. Example: `const post = Posts.findIndex(post => post === 'whatevercodehere')` similar to `.find()` is a true/false type deal. `console.log`ing would output whatever index.


- - - 


`Array.some()` & `Array.every()`

These are not part of ES6, but apparently Wes doesn't feel they get the love they deserve so he's covering them :D

They check the data in an array to check if some of the items meet criteria you're looking for or all items meet what you're looking for.

`Array.some()`:
```
const ages = [15, 13, 25, 30, 32];

// is there atleast one person over 18/adult

const adultPresent = ages.some(age => age >= 18);
console.log(adultPresent); // outputs true as soon as it hits 25

```

`Array.every()`:
```
const ages = [15, 13, 25, 30, 32];

// is everyone old enough to drink

const oldEnoughToDrink = ages.every(age => age >= 21);
console.log(oldEnoughToDrink); // outputs false since there are youngins in the squad

```


### ...spread & ...rest

Using a `.concat()` to combine two arrays makes sense, but this `...spread` is too sweet not to prefer.

`.concat()`
```
const featured = ['Deep Dish', 'Pepperoni', 'Hawaiian'];
const specialty = ['Meatzza', 'Spicy Mama', 'Margherita'];

const combineArrays = featured.concat(specialty);
console.log(combineArrays);

```

To throw something in the middle though using `...spread`, saves lines of reassigning variables and using `.push()` and all that jazz
```
const featured = ['Deep Dish', 'Pepperoni', 'Hawaiian'];
const specialty = ['Meatzza', 'Spicy Mama', 'Margherita'];

const combineArrays = [...featured, 'veggie', ...specialty, 'vegan'];
console.log(combineArrays);

```

Sweeten the pot though, when 'copying' an array
```
const featured = ['Deep Dish', 'Pepperoni', 'Hawaiian'];
const weekendSpecial = featured;

weekendSpecial[0] = 'NY Style';

console.log(weekendSpecial); // ['NY Style', 'Pepperoni', 'Hawaiian'] :D
console.log(featured); // also ['NY Style', 'Pepperoni', 'Hawaiian'] now >_<

```
I wanted to make a copy of the featured options, but change one just for the weekends. However, changing the first item from my 'copy' actually changed the original featured array because it was in fact referencing. The two, in this manner, were not seperate. *booooo*

What can be done? Well, `.concat()` is an option...
```
const featured = ['Deep Dish', 'Pepperoni', 'Hawaiian'];
const weekendSpecial = [].concat(featured); // copies instead of references

weekendSpecial[0] = 'NY Style';
  
console.log(weekendSpecial); // ['NY Style', 'Pepperoni', 'Hawaiian'] :D
console.log(featured); // ['Deep Dish', 'Pepperoni', 'Hawaiian']; :D

```

BUT, you can ALSO use that shweeet `...spread` to get that copy without `.concat()`
```
const featured = ['Deep Dish', 'Pepperoni', 'Hawaiian'];
const weekendSpecial = [...featured]; // copies instead of references

weekendSpecial[0] = 'NY Style';

console.log(weekendSpecial); // ['NY Style', 'Pepperoni', 'Hawaiian'] :D
console.log(featured); // ['Deep Dish', 'Pepperoni', 'Hawaiian']; :D

```

TL;DR
A spread will take all things from specified array/iterable and throw it into the new array.


- - -


Messing with SPREAD
```
   .jump span {
      display: inline-block; /* span is inline, making it inline-block will allow the hover animation */
      transition: transform 0.2s;
      cursor:url('http://csscursor.info/source/santahand.png'), default;
    }
    .jump span:hover {
      transform: translateY(-20px) rotate(10deg) scale(2);
    }
  </style>
</head>
<body>
  <h2 class="jump">SPREADS!</h2>

<script>
const heading = document.querySelector('.jump');
heading.innerHTML = spanWrap(heading.textContent);
console.log(heading);
 
function spanWrap(word) {
  return [...word].map(letter => `<span>${letter}</span>`).join('');
} 

</script>
</body>
</html>

``` 
Didn't add all CSS associated, but the point is to show spread being used within a function on a string where each letter is animated to move on hover.

RANDOM NOTE: something I'm not sure I've figured out when needed, but did not know off the top of my head... you can't animate a span(inline), inline-block is what got it to ^work.


- - -

MOAAAAR [or *more*, for the serious] spread examples:

I. Kicking it off with a NodeList:
```
const dogs = document.querySelectorAll('.dogs p');

console.log(dogs); // NodeList atm

```
^As is, you can't map this baby, but we totally have done this before soooo...

We can use an `Array.from()` to convert our NodeList into an Array:
```
const dogs = Array.from(document.querySelectorAll('.dogs p'));
console.log(dogs); // yay Array 

const names = dogs.map(dog => dog.textContent);
```

Or... it's totally possible to use a spread on the doc selector line (O_O)
```
const dogs = [...document.querySelectorAll('.dogs p')];
console.log(dogs); // yay Array

const names = dogs.map(dog => dog.textContent);

```

II. When creating a new array off an object property:
```
const joSpecial = {
    pizzaName: 'joSpecial',
    size: 'Medium',
    ingredients: ['Marinara', 'Spinach', 'Dough', 'Cheese', 'Banana Pepper']
  };

const groceryList = ['leche', 'flour', ...joSpecial.ingredients];
console.log(groceryList);

```
^Combines lists, true copy not reference.

III. When you have an array of objects and need/want to remove one of them:
```
const comments = [
  {id: 111222, text: 'Your dog is adorable'}, 
  {id: 222333, text: 'Swoooooon'}, 
  {id: 333444, text: 'Please evaporate'}, 
  {id: 444555, text: 'I miss your FACE'}
];

console.log(comments);

```

You want to remove the comment asking you to 'Please evaporate', so u snag id of that comment to find out position in array:
```
const id = 333444;

const removeIndex = comments.findIndex(comment => comment.id === id); 

console.log(removeIndex); // 2

```

You find out it's at index 2, so let's remove that sucker using `slice()`:
```
const keepers = [comments.slice(0, removeIndex), comments.slice(removeIndex + 1)];

console.log(keepers); // removes, but leaves you with an array of arrays

```

You got it removed and all, buuuuut you got an array of 2 arrays... the fix? use SPREAD
```
const keepers = [...comments.slice(0, removeIndex), ...comments.slice(removeIndex + 1)];

console.log(keepers); // one full array

```
Now, we got ourselves a nice little array of lovely comments that make your heart smile :D


### spreading into a function

I.

Using `.push()` is cool and all, but it will give you one of those situations where you get an array within an array
```
const inventors = ['Einstein', 'Newton', 'Galileo'];
const newInventors = ['Musk', 'Jobs'];

inventors.push(newInventors);

console.log(inventors); // gives an array within an array

```

You do got that `.push.apply()` option that does in fact give you the combined array you're looking for
```
inventors.push.apply(inventors, newInventors);

console.log(inventors); // this gives whole array containing all 5 inventors

```

But, then you got that *spread* option that (imo) looks so much prettier to read
```
inventors.push(...newInventors);

console.log(inventors); // using spread takes that array passing each item as individual arguments, spread into function

```

II.

```
const name = ['jo', 'shmo'];

function sayHi(first, last) {
  alert(`Hi ${first} ${last}!`);
}

sayHi(...name);

```
^Instead of doing something like `sayHi(name[0], name[1]);`, time saver especially if there were more arguments to throw in there.


### ...rest param
`...rest` param looks like `...spread`, but does the opposite. While ...spread unpackages an array, ...rest bundles them. 

I. used in a function

Something like `function convertCurr(rate, amt1, amt2, amt3, amt4) {}` or instead, toss all that and use `arguments`, `function convertCurr() {arguments}`.

Since we want the first thing to be the rate and then the *rest* to be the amounts one would like to convert we use a ...rest to package various ammounts into a tidy array :D
```
function convertCurr(rate, ...amounts) {
  console.log(rate, amounts); // outputs 1.54 (rate) and then the rest (amounts) Array(5) [ 10, 23, 52, 1, 56 ]
  return amounts.map(amount => amount * rate);
}

const amounts = convertCurr(1.54, 10, 23, 52, 1, 56);

console.log(amounts); // outputs Array(5) [ 15.4, 35.42, 80.08, 1.54, 86.24000000000001 ]

```


II. used in a destructuring situation

`const crew = ['Han', 'Chewie', 'Luke', 'C3PO', 'R2D2'];` takes pilot, copilot, and the *rest* of the passengers.

To group the passengers together, and since it is an array we are destructuring we use `[]` and three variables we are packing things into -> pilot, copilot, ...passengers

Using rest bundles up the passengers into a nice tidy array.

```
const crew = ['Han', 'Chewie', 'Luke', 'C3PO', 'R2D2'];

const [pilot, copilot, ...passengers] = crew;

console.log(pilot, copilot, passengers); // outputs Han Chewie Array(3) [ "Luke", "C3PO", "R2D2" ]

```

NOTE: Don't forget to take out the ...rest when copy/pasting into console.log *>_<*


### object literal upgrades

If property name and variable setting it to are the same, they don't need to be written twice:
```
const name = 'enigma';
const age = 12;
const breed = 'lab mix';

// this 
const dog = {
  name: name, 
  age: age, 
  breed: breed
};

// same as this
const dog = {
  name, 
  age, 
  breed
};

console.log(dog);

```

Method definitions:

Instead of this...
```
const modal = {
  create: function() {

  },
  open: function() {
    
  }
  close: function() {
    
  },
}

```

able to shorthand to this...
```
const modal = {
  create() {

  },
  open() {
    
  }
  close() {
    
  },
}

```

use with params...
```
const modal = {
  create(paramHere) {

  },
  open(paramHere) {
    
  }
  close(paramHere) {
    
  },
}

```

Computed property names:
```
const key = 'pocketColor';
const value = 'blue';

const tshirt = {
  [key]: value // always possible
};

console.log(tshirt); // outputs Object { pocketColor: "blue" }

```

So, *what's new?*

Ability to compute property keys inside of obj literal as we define it. Compute copy; use function, template string or any other JS inside of property name. Properties/ values being dynamically set.

```
// invertColor(value) would be a function where value would be taken in and output opposite color

const key = 'pocketColor';
const value = 'blue';

const tshirt = {
  [key]: value,
  [`${key}Opposite`]: invertColor(value)
};

console.log(tshirt); // outputs Object { pocketColor: "blue", pocketColorOpposite: "yellow" }

```

Previously,
```
const key = 'pocketColor';
const value = 'blue';

const tshirt = {}; // make tshirt obj

// update tshirt object (below)
tshirt[key]= value,
tshirt[`${key}Opposite`]= invertColor(value)

console.log(tshirt); // outputs Object { pocketColor: "blue", pocketColorOpposite: "yellow" } 

```

APIs and their sometimes janky data example:
```
const keys = ['size', 'color', 'weight'];
const values = ['med', 'black', 100];

const shirt = {
	[keys[0]]
}

```

^computed property type name, but another option is something like the following
```
const keys = ['size', 'color', 'weight'];
const values = ['med', 'black', 100];

const shirt = {
  [keys.shift()]: values.shift(),
  [keys.shift()]: values.shift(),
  [keys.shift()]: values.shift(),
}

console.log(shirt); // outputs Object { size: "med", color: "black", weight: 100 } O_O

```
Essentially, snagging each key, value as it goes through.

This seems a little odd to me as I'm repeating code. Doing some sort of looping would seem to make more sense, maybe. Maybe there's more to this... Presently, I don't see it, but I'm a n00b so... I def need to come back to this.