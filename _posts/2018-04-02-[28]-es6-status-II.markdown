---
layout: post
title:  "ES6 Status II"
date:   2018-04-02
categories: javascript
---

### destructuring objects

Can extract data from arrays, objects, maps and sets.

This I actually found pretty cool. There have been a few instances I have broken down things into multiple parts, writing extra... until...

```
let quote = item.saying;
let author = item.author;

```

vs.

```
let { saying:quote, author } = item;

```

How awesome is that?^ AND the `saying:quote` part is me storing `saying` into `quote` variable! Yes, I dig it and am stoked to use it.

Destructuring would also come in handy for deep nested data, like with an API. Thinking back, I'm pretty sure the Dark Sky API I used for my weather app had a few of those.

```
const you = {
	first: 'NAME HERE'
	links: {
		social: {
			twitter: 'https://twitter.com/USERNAME', 
			github: 'https://github.com/USERNAME'
		}
	}
}

const { twitter, github } = you.links.social;

```

SETTING DEFAULTS:

`const settings = { width: 500, color: 'black' }` 

`const { width=100 height=500, color='pink', fontSize=32 } = settings;`

2nd line above has defaults set, in other words as it deconstructs settings obj it checks if there's a match. If so, it moves on and if not, it takes the default.

BREAKDOWN: width is included in the 1st line (settings) so it stays at 500, height takes 500 which is set as default in 2nd line (destructuring line), there is color in settings so it stays black, but fontSize, like height is not so it takes default set, 32

### destructuring arrays

Just like objects, there's a way to simplify life with arrays. The difference, object destructuring uses curly braces, while arrays used square brackets.

```
const details = ['scrappy', '14', 'brindle'];

const name = details[0];
const age = details[1];
const age = details[2];


```

vs.

```
const details = ['scrappy', '14', 'brindle'];

const [name, age, color] = details;

console.log(name, age, color); // scrappy 14 brindle

```

Note: There will also be a difference when destructuring maps and sets, maps uses curly braces, while sets use square brackets.

Also helpful when dealing with a [comma] list/string:

```
const data = 'sport, basketball, shaq, 32, retired';

const[category, type, player, number, status] = data.split(',');

console.log(category, type, player, number, status);

```

^At first, I had used a `let` instead of `const` to split data and reassign variable, but turns out there is a simplier/ better way to do that and that's just add it to the destructure (w00t!)

```
const data = 'sport, basketball, shaq, 32, retired, yourFace';

const[category, type, player, number, status] = data.split(',');

console.log(category, type, player, number, status);

```
^What happens when you want to destructure something that doesnt match length of array? Nothing.
Output will actually remain the same since the last part of the string was not destructured.

But, how about those times you do want the rest?
```
const cockpit = ['Clarence', 'Roger', 'Striker', 'Doctor', 'Nun'];

const [pilot, co-pilot, ...passengers] = cockpit;

```
^ you'd destructure as usual, but use the *rest operator* to snag the *rest* :D

### swapping variables with destructuring

When you need to toggle between variables:
```
let onCourt = 'DWade';
let offCourt = 'UD';

console.log(onCourt, offCourt); // will show org

[onCourt, offCourt] = [offCourt, onCourt];

console.log(onCourt, offCourt); // will show swap

```
^ Will create an array and destructure into opp variables. Since updating variables -> using `let`

### destructuring functions - multi returns + named defaults

Multi- Returns:
```
function convertCurrency(amount) {
	const converted = {
		USD: amount * 0.76,
		MEX: amount * 13.30,
		GPB: amount * 0.53
	}
	return converted;
}

const hundo = convertCurrency(100);
console.log(hundo);

console.log(hundo.MEX); // to return specific value

```
Destructuring to return multi values from a function is a cheat since you can't *really*, but u *can* return an obj with a restructured answer.

```
function convertCurrency(amount) {
	const converted = {
		USD: amount * 0.76,
		MEX: amount * 13.30,
		GPB: amount * 0.53
	}
	return converted;
}

const {  MEX, USD, GPB } = convertCurrency(100);

console.log(USD, MEX, GPB);

```
^Desctructuring in this manner, able to snag specific value. The order that is is destructured doesn't affect value return since it is an object.

Note: It isnt necessary to destructure all if, let's say, only USD and GPB is needed.

Named Defaults:
```
function tipCalc({total, tip=0.15, tax=0.13}) {
	return total + (tip * total) + (tax * total);
}

const bill = tipCalc({ total: 200, tax: 0.09 });
console.log(bill);

```
Making order of values independent, you wrap params in curly braces. Pass obj will destructure into 3 variables (total, tip, tax)/make available inside function. When called, you pass obj with values, they do not have to be in exact order and it is possible to leave unneeded values out.

If NO arguments are passed:
```
function tipCalc({total=200, tip=0.25, tax=0.09} = {}) {
	return total + (tip * total) + (tax * total);
}

const bill = tipCalc();
console.log(bill);

```

For cases where no obj are passed to destructure against, calling function, you have to give itself a default argument. If no object is passed it will default to blank obj and all defaults will be in there.

### iterables & looping

`const dogs = ['beagle', 'dalmation', 'golden retriever', 'pug', 'labrador'];`


The classic `for loop`
The following type of for loop became the main one used, but only after getting some used to. Although, it does do what it's meant to do, syntax may not be as readable as it could be.
```
for(let i = 0; i < dogs.length; i++) {
  console.log(dogs[i]);
}

```


Then, there's the `forEach`
This one actually made the most sense to me when I first started trying to wrap my head around JavaScript. The reason, I got my basic grasp of web dev workings messing with Ruby which had something similar.
```
dogs.forEach((dog) => {
	console.log(dog);
})

```
Cannot pause loop, cannot skip items
Cannot use `break` or `continue` inside a `forEach` loop


The `for in` loop:
```
for(const index in dogs) {
	console.log(dogs[index]);
}

``` 
This gives index, snag values as follows, but...

there are many methods on a prototype, if you were to add one and then reiterate it will reiterate all things in array including anything added. [example] custom prototype method or property added to array.


The `for of` loop:
```
for(const dog of dogs) {
	console.log(dog)
}

```
This is like the one that brings all the good stuff from those above into one, sorta. It will return what is in the array w/o anything extra like if prototype was modified and able to use `break` and `continue`. NOTE: `for of` loops can be used on anything except objects.

### for of loop on the field

```
for(const dog of dogs) {
	console.log(dog)
}

// will output:
beagle
dalmation
golden retriever
pug
labrador

```

^Seems there really isnt a good way to snag index.

In comes `dogs.entries()` which `console.log`s an Array Iterator with a `next()` method
```
dogs.entries()
	Array Iterator
	​
		__proto__: Array Iterator
		​​
		next: next()
		​​​
		length: 0
		​​​
		name: "next"
		​​​
		__proto__: ()
		​​​​
		apply: function apply()
		​​​​
		arguments: null
		​​​​
		bind: function bind()
		​​​​
		call: function call()
		​​​​
		caller: null
		​​​​
		constructor: function Function()
		​​​​
		length: 0
		​​​​
		name: ""
		​​​​
		toSource: function toSource()
		​​​​
		toString: function toString()
		​​​​
		Symbol(Symbol.hasInstance): undefined
		​​​​
		__proto__: Object { … }
		​​
		Symbol(Symbol.toStringTag): undefined
		​​
		__proto__: {…}
		​​​
		Symbol(Symbol.iterator): undefined
		​​​
		__proto__: Object { … }

```
When stored in a variable `const pups = dogs.entries();` you are able to iterate manually `pups.next();`, but placing it within `for of` loop `console.log`s

```
for(const dog of dogs.entries()) {
	console.log(dog)
}

// will output:
Array [ 0, "beagle" ]
Array [ 1, "dalmation" ]
Array [ 2, "golden retriever" ]
Array [ 3, "pug" ]
Array [ 4, "labrador" ]

```

However, present setup requires `console.log(dog[0], dog[1]);` to get index with dog
```
// console.log output:
0 beagle
1 dalmation
2 golden retriever
3 pug
4 labrador

```

A better approach, destructuring with optional use of template strings
```
for(const [i, dog] of dogs.entries()) {
	console.log(`${i}: ${dog}`);
}

// will output:
0: beagle
1: dalmation
2: golden retrieve
3: pug
4: labrador

```

Iterating using `arguments`:
```
function addUpNum() {
	let total = 0;
	for (num of arguments) {
		total += num;
	}
	console.log(total);
	return total;
}

addUpNum(10, 20, 32, 35, 15); // 112

```

Using arguments gives you something similar to an array, but it is NOT an array. 
```
function addUpNum() {
	console.log(arguments);	
}

addUpNum(10, 20, 32, 35, 15); // 112

// console.log returns:

Arguments
​
0: 10
​
1: 20
​
2: 32
​
3: 35
​
4: 15
​
callee: function addUpNum()
​
length: 5
​
Symbol(Symbol.iterator): undefined
​
__proto__: Object { … }

```

A true array will show prototype methods included with arrays, arguments will only provide length. However, arguments will provide iterator method.
```
// console.log([10, 20, 32, 35, 15]) returns

Array(5) […]
​
0: 10
​
1: 20
​
2: 32
​
3: 35
​
4: 15
​
length: 5
​
__proto__: []
​​
concat: function concat()
​​
constructor: function Array()
​​
copyWithin: function copyWithin()
​​
entries: function entries()
​​
every: function every()
​​
fill: function fill()
​​
filter: function filter()
​​
find: function find()
​​
findIndex: function findIndex()
​​
forEach: function forEach()
​​
includes: function includes()
​​
indexOf: function indexOf()
​​
join: function join()
​​
keys: function keys()
​​
lastIndexOf: function lastIndexOf()
​​
length: 0
​​
map: function map()
​​
pop: function pop()
​​
push: function push()
​​
reduce: function reduce()
​​
reduceRight: function reduceRight()
​​
reverse: function reverse()
​​
shift: function shift()
​​
slice: function slice()
​​
some: function some()
​​
sort: function sort()
​​
splice: function splice()
​​
toLocaleString: function toLocaleString()
​​
toSource: function toSource()
​​
toString: function toString()
​​
unshift: function unshift()
​​
values: function values()
​​
Symbol(Symbol.iterator): undefined
​​
Symbol(Symbol.unscopables): undefined
​​
__proto__: Object { … }

```

NOTE: It is possible and sometimes may be neccessary to convert `arguments` into an array, but if kept as is those would be differences to keep in mind.








