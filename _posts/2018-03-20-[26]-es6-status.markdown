---
layout: post
title:  "ES6 Status"
date:   2018-03-20
categories: javascript
---

This is me yellow brick road-ingâ€¦ to better grasp JS/ES6

### var scope

`var` can be updated and redefined. They are also function-scoped, which means they can only be used within the function they were declared (local) unless global. Global means they are available from wherever they are called.

When used within an if statement block (no function) the var/value will leak out because it doesnt stay local (not block-scoped). That can be a problem.

### let & const

`let` and `const` are block-scoped variables. 

### let

when using `let` redeclaring will give error unlike `var` that will allow the redeclare giving no error (redeclaring `var` can cause a problem if for whatever reason you forget you used a particular variable name somewhere else in the script). You can reassign however.

using a `let` variable of the same name in different scopes will be treated independently.


### const

when using `const` variable, they cannot be updated (unlike `let`)

### using var & let & const

having a `var` as a global variable can be problematic using certain variables as it may accidently interfere with the window itself-- 

using `var name = JO;`

good practice is to place it within an IIFE (pronounced 'iffy'), Immediately-Invoked Function Expression, a function that runs itself creating scope and preventing leak into parent scope. In this case it would be the window. 

checking for name will work, however window has `name` attribute
(ex: needing opening of 2nd window) or perhaps an attribute used by something else you happen to use (ex: 3rd party)

hence, the usage of IIFE mentioned above.

```
(function(){
	var name = JO;
	console.log(name); // JO
})();

// "" showing blank/empty outside of scope as it is a window property, meaning var used previously is not leaking outside function
```

using `const name = JO;`
would return the same used globally, but to prevent leaking in this case it just needs to be used within a block

```
{
  const name = JO;
	console.log(name); // JO
}

// outside will return "" same as before, name is window property
```

### for loops

```
for(var i=0; i < 10; i++) {
	console.log(i);
}

// here var i would iterate and count to 9, but calling i would show value of ten, var, global var, leaked
```

another example of var behavior...
```
for(var i=0; i < 10; i++) {
	setTimeout(function() {
		console.log(i);
	}, 1000);
}

// by the time setTimeout runs (in this case 1 sec) it would have iterated through, the number 10 will output 10x instead of iterating and counting through to 9 as with previous example

why? not outputting right away as with first example, var is being reassigned/overwritten.

Similar to AJAX request iteration, no good way than use an IIFE? to ref i --why?
```

swapping out `var` for `let`...
```
for(let i=0; i < 10; i++) {
	setTimeout(function() {
		console.log(i);
	}, 1000);
}

// this will output correctly, iterating and counting as each value of i passes through and no 10 as with initial example, the variable is not global, it is block-scoped
```

`const` as mentioned before cannot be used^, not allowed to use variable more than once, will shoot out error

### temporal zone? Meh, how about the phantom zoooone :D

```
var soda = 'Coke';
console.log(soda);

// this will output 'Coke' 

```

if we switch it up?

```
console.log(soda);
var soda = 'Coke';

// this will output 'undefined', it will find the var variable, but not the var value (ex: 'Coke') in comparison to using const & let where you cannot access variable before it is defined

```

### so... no var then?

`const` is not immutable, it creates an immutable binding.

For example:
```
const whut = {}
whut.who = 'you';
console.log(whut.who) // 'you'

// above is acceptable

```

vs.

```
const whut = 32
whut = 7; // assignment operators
console.log(whut);

// above will throw out TypeError exception

```

vs.

```
const whut = 32
whut.who = 7;
console.log(whut.who) // undefined

// above will throw out an error

```

leading opinions on usage as follows...

[Mathias Bynens]
- use `const` as default
- use `let` when rebinding is needed (which means updating variable)
- `var` should not be used in ES6

[Kyle Simpson]
- use `var` for top-level variables shared across many (~larger) scopes
- use `let` for localized variables in smaller scopes
- refactor `let` to `const` only after reasonable certainty there shouldn't be variable reassignment

For immutable values, to make immutable arrays/objects use `Object.freeze();`

Do not use `const` to make constant (immutable) values, use for non-reassignable variables

- - -
## arrow functions

concise, impicit returns (allowing one-liners), doesn't rebind value of `this` when using arrow function within other function.

`const kids = ['bandit', 'flavor', 'scrappy'];`

original, non-arrow function:
```
const withLastInitial = kids.map(function(kid) {
  return `${kid} P`;  
});

console.log(withLastInitial);
```

using arrow function:
```
const withLastInitial2 = kids.map((kid) => {
  return `${kid} P`;  
});

console.log(withLastInitial2);
```

when only passing 1 parameter (same as above):
```
const withLastInitial2 = kids.map((kid) => {
  return `${kid} P`;  
});

console.log(withLastInitial2);
```

or... you can remove parenthesis, they aren't needed:
sidebar: imo, I think it looks odd and I rather have the parenthesis like above, seems nicer/readable

```
const withLastInitial3 = kids.map(kid => {
  return `${kid} P`;  
});

console.log(withLastInitial3);
```

implicit return:
meaning `return` isn't stated (explicitly), in the case below it is assumed

```
const withLastInitial4 = kids.map(kid => `${kid} P`);

console.log(withLastInitial4);
```

if no there were to be no arguments:
```
const withLastInitial5 = kids.map(()=> `whut whut`);

console.log(withLastInitial5);
```

NOTE: all arrow functions are anonymous functions, not named

ex: `function() { ... }` vs `function nameGoesHere() { ... }`

Using named functions can benefit you when troubleshooting an error. Personally, I like to name my functions for readability, kinda like a title of an article, it gives a headsup of what to expect/ what is it supposed to be doing/ what is it for/ etc.,

It is possible to put the function in a variable:
```
const nameGoesHere = (param) => { alert(`hey ${param}!`)}

nameGoesHere('you'); // alert box will pop up saying 'hey you!'

```

function declaration, still anon function, still wont be very useful for stack traces (something to keep in mind)

### more on arrow functions
#### implicit return w/ obj literal
```
const soda = 'coke';
const whatKind = ['zero', 'diet', 'cherry', 'original'];

// {
//  whatKind: whatKind,
//  soda: soda
// }

const pop = whatKind.map((whatKind, i) => ({name: whatKind, soda: soda, order: i}))
```
NOTE: without the outer parenthesis you will get a syntax error^
Why? The removal of the curly brackets would do an implicit return, however to do an implicit return on an object literal, not actual function block you need to enclose it with a pair of parenthesis-- it shows you are returning an object literal

ANOTHER NOTE: and a pretty sweet one... use `console.table(pop)` will spit out info in a pretty table. Much nicer than using Object dropdowns in console

`const pop = whatKind.map((whatKind, i) => ({name: whatKind, soda, order: i}))`
the use of `variableName: propertyName` is not necessary when the same (es6 feature, cuts redundancy)

another example:
```
const ages = [15, 18, 21, 25, 32, 50, 55, 82];

// grab all 50/over

// const overFifty = ages.filter( age => if(age >= 50));

const overFifty = ages.filter( age => age >= 50 );
console.log(overFifty);
```
first thought, to use if statement, but unnecessary since able to pass condition -- filter will return if true and not if false

what returns true will be put into `overFifty` array

### this
using `this` with an arrow function does not bind the `this` to the function, it inherits from the parent

```
const box = document.querySelector('.box');
box.addEventListener('click', function() {
  console.log(this);
})

```

`this` will reference `box` using normal function (above example)

```
const box = document.querySelector('.box');
box.addEventListener('click', () => {
  console.log(this);
})

```

using an arrow function `this` will reference/ inherit parent scope, in this case, window (above example)-- why? because `this` does not bind to function when arrow functions are used. 

another example of inheritence and all that `this` jazz:
```
const box = document.querySelector('.box');
box.addEventListener('click', function() {
  this.classList.toggle('opening');
  // up to this point, this references box
  setTimeout(function() {
    // here, however, this references window
    this.classList.toggle('open');
  }, 5000);
})

```
the `this` used inside the setTimeout will reference window because we are using a new function, this is not bound, but inherits from parent (window) unlike...
```
const box = document.querySelector('.box');
box.addEventListener('click', function() {
  this.classList.toggle('opening');
  // up to this point, this references box
  setTimeout(() => {
    // here, using an arrow function will inherit, in this case, box (as intended)
    this.classList.toggle('open');
  }, 5000);
})

```

### default function arguments

some things you can do: 
```
function calculate(total, tax, tip) {
  return total + (total * tax) + (total * tip);
}

const fullTotal = calculate(100, 0.7, 0.20);
console.log(fullTotal);
```

able to set default w/ es6:
```
function calculate(total, tax=0.7, tip=0.20) {
  return total + (total * tax) + (total * tip);
}

const fullTotal = calculate(100);
console.log(fullTotal);
```
not passing all arguments, in this case total, tax, tip they will still be implied (above example)

this is cleaner and leaner way than using an if statement for tax and tip === undefined
sidebar: undefined would be what would come up if when arguments not passed or default set up top

able to update and not have to put all params:
```
function calculate(total, tax=0.7, tip=0.20) {
  return total + (total * tax) + (total * tip);
}

const fullTotal = calculate(100, undefined, 0.25);
console.log(fullTotal);
```
above, I'm able to bump up tip percentage from what was used in default and skip over tax value by placing undefined-- you cant't just leave a blank space there, it will shoot out an error

what will happen is there will be a check for undefined defaulting to default value of 0.7 tax




